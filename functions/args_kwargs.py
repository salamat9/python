# Задача. определите функцию, которая принимает любое количество аргументов.

# Решение. Чтобы определить функцию, которая принимает любое количество позиционных
# аргументов, используйте аргумент со звездочкой (*argument):

def avg(first, *args):
    return (first + sum(args)) / (1 + len(args))


print(avg(1, 2))
print(avg(1, 2, 3, 4))


# Чтобы принять любое количество именованных аргументов, используйте аргумент,
# который начинается с **.

# Например:

def make_element(name, value, **kwargs):
    key_values = [' %s="%s"' % item for item in kwargs.items()]
    kwargs_str = ''.join(key_values)
    return f'<{name}{kwargs_str}>{value}</{name}>'


print(make_element('h1', 'Albatross', size='large', id=''))
print(make_element('p', '<spam>'))


# Если вам нужна функция, которая может принимать и любое количество позиционных, и
# любое количество именованных аргументов, используйте * и ** вместе.

# Например:

def any_args(*args, **kwargs):
    """
    В этой функции позиционные аргументы попадают в кортеж args,
    а все именованные аргументы – в словарь kwargs.
    """
    print(args)
    print(kwargs)


any_args(1, 2, 3, first=1, second=2, third=3)


# Аргумент со * может быть только последним в списке позиционных аргументов в
# определении функции. Аргумент с ** может быть только последним. Тонкость тут
# в том, что аргумент без звездочки может идти и после аргумента со звездочкой:

def a(x, *args, y):
    pass


def b(x, *args, y, **kwargs):
    pass


# Задача. Вам нужна функция, которая принимает только именованные аргументы.
# Решение. Эту возможность легко реализовать, если вы поместите именованные
# аргументы после аргумента со звездочкой или символа звездочки.

# Например:

def receive(maxsize, *, block):
    """
    Receives a message
    """
    pass


# receive(1024, 'b') вернёт TypeError
receive(1024, block='b')
# print(help(receive))

# Этот прием может быть также использован для определения именованных аргументов
# в функциях, которые принимают различное количество позиционных аргументов.

# Например:

def minimum(*values, clip=None):
    m = min(values)
    if clip is not None:
        # тернарный оператор - это присвоение значения переменной, через условие.
        m = clip if clip > m else m
    return m


print(minimum(1, 5, 2, -5, 10))
print(minimum(1, 5, 2, -5, 10, clip=0))


# Обсуждение
# Обязательные именованные аргументы часто являются хорошим способом увеличить понятность
# кода при определении необязательных аргументов. Например, посмотрите на такой вызов:
# message = receive(1024, False)
# Пользователь, который незнаком с функцией receive, не имеет представления о том, что означает
# аргумент False. С другой стороны, такой вызов будет намного более ясным:
# message = receive(1024, block=False)
# Использование обязательных именованных аргументов часто предпочтительнее трюков
# с применением **kwargs, поскольку они правильно показываются, когда пользователь просит помощи:
# help(receive)
# Help on function receive in module __main__: receive(maxsize, *, block)
# Receives a message